<% puts "// WARNING: This swift file is auto generated. Don't modify this file directly.\n\n" %>
<% arguments = 1..20 %>
@_exported import Pure
@_exported import Swinject
@_exported import SwinjectAutoregistration

public extension Container {
<% for i in arguments %>
<% args = (1..i).map { |j| "Arg#{j}" }.join(", ") %>
  func autoregister<Module, <%= args %>>(_ factory: Factory<Module>.Type, dependency: @escaping ((<%= args %>)) -> Module.Dependency) where Module: FactoryModule {
<% if i == 1 %>
    if Arg1.self == Void.self {
      self.register(Void.self) { _ in Void() }
    }
<% end %>
    self.autoregister(Module.Dependency.self, initializer: dependency).inObjectScope(.container)
    self.autoregister(factory).inObjectScope(.container)
  }

<% end %>
  @discardableResult
  private func autoregister<Module>(_ factory: Factory<Module>.Type) -> ServiceEntry<Factory<Module>> where Module: FactoryModule {
    self.register((() -> Module.Dependency).self) { r in
      // If the dependency is resolved lazily, the container cannot verify missing dependencies.
      // But it can cause overhead so we need to find a better solution in the future.
      let dependency = r.resolve(Module.Dependency.self)!
      return { dependency }
    }
    return self.autoregister(Factory<Module>.self, initializer: Factory<Module>.init)
  }
}

public extension Container {
<% for i in arguments %>
<% args = (1..i).map { |j| "Arg#{j}" }.join(", ") %>
  func autoregister<Module, <%= args %>>(_ configurator: Configurator<Module>.Type, dependency: @escaping ((<%= args %>)) -> Module.Dependency) where Module: ConfiguratorModule {
<% if i == 1 %>
    if Arg1.self == Void.self {
      self.register(Void.self) { _ in Void() }
    }
<% end %>
    self.autoregister(Module.Dependency.self, initializer: dependency).inObjectScope(.container)
    self.autoregister(configurator).inObjectScope(.container)
  }

<% end %>
  @discardableResult
  private func autoregister<Module>(_ configurator: Configurator<Module>.Type) -> ServiceEntry<Configurator<Module>> where Module: ConfiguratorModule {
    self.register((() -> Module.Dependency).self) { r in
      // If the dependency is resolved lazily, the container cannot verify missing dependencies.
      // But it can cause overhead so we need to find a better solution in the future.
      let dependency = r.resolve(Module.Dependency.self)!
      return { dependency }
    }
    return self.autoregister(Configurator<Module>.self, initializer: Configurator<Module>.init)
  }
}
